package org.skramer.spodddify.payment;

import static org.assertj.core.api.Assertions.assertThat;
import static org.axonframework.test.matchers.Matchers.andNoMore;
import static org.axonframework.test.matchers.Matchers.exactSequenceOf;
import static org.axonframework.test.matchers.Matchers.matches;

import org.axonframework.eventhandling.EventMessage;
import org.axonframework.test.aggregate.AggregateTestFixture;
import org.axonframework.test.aggregate.FixtureConfiguration;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.Test;
import org.skramer.spodddify.payment.command.CreateBillingAccountCommand;
import org.skramer.spodddify.payment.domain.PaymentPlan;
import org.skramer.spodddify.payment.event.BillingAccountCreatedEvent;

public class BillingAccountTest {
    private static final String DUMMY_BILLING_ACCOUNT_ID = "dummyAccountId";
    private static final long INITIAL_BALANCE = 0L;
    private FixtureConfiguration<BillingAccount> fixture;

    @Before
    public void setUp() {
        fixture = new AggregateTestFixture<>(BillingAccount.class);
        fixture.registerAnnotatedCommandHandler(new BillingAccountCommandHandler(fixture.getRepository(), fixture.getEventBus()));
    }

    @Test
    public void shouldCreateBillingAccountWithDefaultPlan() {
        fixture.givenNoPriorActivity()
                .when(new CreateBillingAccountCommand())
                .expectEventsMatching(
                        exactSequenceOf(
                                accountWithInitialBalanceAndPlan(PaymentPlan.FREE),
                                andNoMore()
                        )
                );
    }

    private static Matcher<EventMessage<?>> accountWithInitialBalanceAndPlan(PaymentPlan paymentPlan) {
        return matches(em -> {
            assertThat(em.getIdentifier()).isNotNull();
            assertThat(em.getPayloadType()).isEqualTo(BillingAccountCreatedEvent.class);
            assertThat(em.getPayload()).isEqualToIgnoringGivenFields(new BillingAccountCreatedEvent(DUMMY_BILLING_ACCOUNT_ID, INITIAL_BALANCE, paymentPlan), "accountId");
            return true;
        });
    }

    @Test
    public void shouldCreateBillingAccountWithSpecifiedPlan() {
        fixture.givenNoPriorActivity()
                .when(new CreateBillingAccountCommand(PaymentPlan.PREMIUM))
                .expectEventsMatching(
                        exactSequenceOf(
                                accountWithInitialBalanceAndPlan(PaymentPlan.PREMIUM),
                                andNoMore()
                        )
                );
    }

//    @Test
//    public void shouldCreateBillingAccountWithInitialBalance() {
//        fixture.givenNoPriorActivity()
//                .when(new CreateBillingAccountCommand(BILLING_ACCOUNT_ID, INITIAL_BALANCE))
//                .expectSuccessfulHandlerExecution()
//                .expectEvents(new BillingAccountCreatedEvent(BILLING_ACCOUNT_ID, INITIAL_BALANCE, PaymentPlan.FREE));
//    }
//
//    @Test
//    public void shouldCreateBillingAccountWithInitialBalanceWithAutogeneratedAccountId() {
//        fixture.givenNoPriorActivity()
//                .when(new CreateBillingAccountCommand())
//                .expectSuccessfulHandlerExecution()
//                .expectState(ba -> {
//                    assertThat(ba.getBalance()).isEqualTo(INITIAL_BALANCE);
//                    assertThat(ba.getAccountId()).isNotEmpty();
//                });
//    }
//
//    @Test
//    public void shouldThrowExceptionWhenChargingInexistingAccount() {
//        fixture.givenNoPriorActivity()
//                .when(new ChargeBillingAccountCommand(BILLING_ACCOUNT_ID, CHARGE_AMOUNT))
//                .expectEvents(new BillingAccountNotFoundEvent(BILLING_ACCOUNT_ID));
//    }
}